// work in progress & exploratory

package generator

import (
	"fmt"

	"github.com/brandonc/tfpgen/internal/config"
	"github.com/brandonc/tfpgen/pkg/naming"
	"github.com/brandonc/tfpgen/pkg/restutils"
	"github.com/getkin/kin-openapi/openapi3"
)

// ResourceGenerator is the type that generates code for each resource
type ResourceGenerator struct {
	Doc    *openapi3.T
	Config *config.Config

	currentResource  *restutils.RESTResource
	currentTerraform *config.TerraformResource
}

// TemplateResourceData describes a single resource to be templated
type TemplateResourceData struct {
	PackageName                  string
	AcceptanceTestFunctionPrefix string
	TerraformTypeName            string
	TerraformTypeNameTitle       string
	ConfigKey                    string
	ResourceStruct               string
	Description                  string
	Attributes                   []*TemplateResourceAttribute
}

// TemplateResourceAttribute describes a single resource attribute and can contain other nested attributes
type TemplateResourceAttribute struct {
	// A measure of attribute nesting
	NestingLevel int

	// The Terraform name to use for the attribute. See https://www.terraform.io/language/syntax/configuration#identifiers
	TfName string

	// The OpenAPI description of the property
	Description string

	// The Capital Case field name for the attribute. This casing is important because the
	// data struct that is annotated by the framework has to be publicly exposed in go code
	DataName string

	// The Terraform Plugin Framework schema type, for example, "types.StringType"
	FrameworkSchemaType string

	// The Terraform Plugin Framework attribute data type, for example, "types.String"
	FrameworkDataType string

	// If the type is a list or map, this is the type of the inner element
	FrameworkElemSchemaType string

	// Whether or not to mark this attribute as sensitive
	Sensitive bool

	// Whether or not the attribute is required
	Required bool

	// If it's not required or computed, the attribute should be optional
	Optional bool

	// Nested attributes that belong to this attribute
	Attributes []*TemplateResourceAttribute

	// IsList determines should be true if this represents an array attribute
	IsList bool

	// IsComplex determines which type of schema this is: simple or composite
	IsComplex bool
}

var _ Generator = (*ResourceGenerator)(nil)

func toTerraformFrameworkSchemaType(tfType string) string {
	if tfType == "string" {
		return "types.StringType"
	} else if tfType == "number" {
		return "types.NumberType"
	} else if tfType == "bool" {
		return "types.BoolType"
	} else if tfType == "map" {
		return "types.MapType"
	} else if tfType == "list" {
		return "types.ListType"
	}
	panic(fmt.Sprintf("invalid tf type \"%s\"", tfType))
}

func toTerraformType(specType string) string {
	if specType == "integer" {
		return "number"
	} else if specType == "string" {
		return "string"
	} else if specType == "boolean" {
		return "bool"
	} else if specType == "object" {
		return "map"
	} else if specType == "array" {
		return "list"
	}
	panic(fmt.Sprintf("invalid spec type \"%s\"", specType))
}

func toGoType(specType string) string {
	if specType == "integer" {
		return "int"
	} else if specType == "string" {
		return "string"
	} else if specType == "boolean" {
		return "bool"
	}
	return "interface{}" // TODO: custom nested data types
}

func (g *ResourceGenerator) Template() string {
	return `// Code generated by tfpgen; DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

type {{ .ResourceStruct }} struct{}

func New{{ .TerraformTypeName }}() resource.Resource {
	return &{{ .ResourceStruct }}{}
}

type {{ .ResourceStruct }}Data struct {
	{{- range $attribute := .Attributes }}
	{{ .DataName }} {{ .FrameworkDataType }} ` + "`tfsdk:\"{{ .TfName }}\"`" +
		`	{{- end}}
}

func (r *{{ .ResourceStruct }}) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .TerraformTypeName }}"
}

{{ define "SimpleAttr" }}
	"{{.TfName}}": {
		MarkdownDescription: "{{ .Description }}",
		Type:                {{ .FrameworkSchemaType }}{{ if .FrameworkElemSchemaType }}{ ElemType: {{ .FrameworkElemSchemaType }}}{{ end }},
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
	},{{ end }}
{{ define "ComplexListAttr" }}
	"{{.TfName}}": {
		MarkdownDescription: "{{ .Description }}",
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
		Attributes:          tfsdk.ListNestedAttributes(map[string]tfsdk.Attribute{
			{{- range $attr := .Attributes }}{{ template "Attr" $attr }}{{- end}}
		}),
	},{{ end }}
{{ define "ComplexAttr" }}
	"{{.TfName}}": {
		MarkdownDescription: "{{ .Description }}",
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
		Attributes:          tfsdk.SingleNestedAttributes(map[string]tfsdk.Attribute{
			{{- range $attr := .Attributes }}{{ template "Attr" $attr }}{{- end}}
		}),
	},{{ end }}
{{ define "Attr" }}{{ if .IsComplex }}{{ if .IsList }}{{ template "ComplexListAttr" . }}{{ else }}{{ template "ComplexAttr" . }}{{ end}}{{ else }}{{ template "SimpleAttr" . }}{{ end }}{{ end }}
func (t *{{ .ResourceStruct }}) GetSchema(ctx context.Context) (tfsdk.Schema, diag.Diagnostics) {
	return tfsdk.Schema{
		MarkdownDescription: "TODO",
		Attributes: map[string]tfsdk.Attribute{
			{{- range $attribute := .Attributes }}{{ template "Attr" $attribute }}{{- end}}
		},
	}, nil
}

func (r *{{ .ResourceStruct }}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.CreateExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "created a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.ReadExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "read a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.Plan.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.UpdateExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "updated a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.DeleteExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }

	resp.State.RemoveResource(ctx)

	tflog.Info(ctx, "deleted a {{ .ResourceStruct }} resource")
}
`
}

func (g *ResourceGenerator) PackageName() string {
	return g.Config.Provider.PackageName
}

func (g *ResourceGenerator) Generate(destinationPath string) error {
	bindings, err := g.Config.AsBindings()
	if err != nil {
		// Provided error message is adequate
		return err
	}

	probe := restutils.NewProbe(g.Doc)
	resources, err := probe.BindResources(bindings)

	if err != nil {
		// Provided error message is adequate
		return err
	}

	for key := range g.Config.Output {
		resource, ok := resources[key]
		if !ok {
			return fmt.Errorf("could not find configured entity key \"%s\" in %s", key, g.Config.Filename)
		}

		if resource.IsCRUD() {
			g.currentResource = resource
			g.currentTerraform = g.Config.Output[key]

			err = execute(g, fmt.Sprintf("%s/resource_%s.go", destinationPath, g.currentTerraform.TfTypeNameSuffix))
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *ResourceGenerator) CreateTemplateData() interface{} {
	return &TemplateResourceData{
		PackageName:                  "provider",
		AcceptanceTestFunctionPrefix: "AccTest_",
		Attributes:                   templateAttributes(g.currentResource, g.currentTerraform),
		TerraformTypeName:            g.currentTerraform.TfTypeNameSuffix,
		TerraformTypeNameTitle:       naming.ToTitleName(g.currentTerraform.TfTypeNameSuffix),
		ConfigKey:                    g.currentResource.Name,
		ResourceStruct:               fmt.Sprintf("Resource%s", g.currentResource.Name),
	}
}

func NewResourceGenerator(doc *openapi3.T, config *config.Config) *ResourceGenerator {
	return &ResourceGenerator{
		Doc:    doc,
		Config: config,
	}
}
