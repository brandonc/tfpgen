// work in progress & exploratory

package generator

import (
	"fmt"
	"os"
	"strings"
	"text/template"

	"github.com/brandonc/tfpgen/internal/config"
	"github.com/brandonc/tfpgen/internal/naming"
	"github.com/brandonc/tfpgen/pkg/restutils"
	"github.com/getkin/kin-openapi/openapi3"
)

type TemplateResourceData struct {
	PackageName                  string
	AcceptanceTestFunctionPrefix string
	TerraformTypeName            string
	FactoryFunctionName          string
	ConfigKey                    string
	ResourceTypeStuct            string
	ResourceStruct               string
	Description                  string
	Attributes                   []*TemplateResourceAttribute
}

type ResourceGenerator struct {
	spec *restutils.SpecResource
	tf   *config.TerraformResource
	oapi *openapi3.T
}

type TemplateResourceAttribute struct {
	NestingLevel  int
	TfName        string
	Description   string
	FrameworkType string
	DataName      string
	DataType      string
	Required      bool
	Attributes    []*TemplateResourceAttribute
}

func toTerraformFrameworkType(tfType string) string {
	if tfType == "string" {
		return "StringType"
	} else if tfType == "number" {
		return "NumberType"
	} else if tfType == "bool" {
		return "BoolType"
	}
	panic(fmt.Sprintf("invalid tf type \"%s\"", tfType))
}

func toTerraformType(specType string) string {
	if specType == "integer" {
		return "number"
	} else if specType == "string" {
		return "string"
	} else if specType == "boolean" {
		return "bool"
	}
	panic(fmt.Sprintf("invalid spec type \"%s\"", specType))
}

var resourceSchemaTemplateBody = `
// Code generated by tfpgen; DO NOT EDIT.
package {{ .PackageName }}

// This is code that will be generated for the config key "{{ .ConfigKey }}"

type {{ .ResourceTypeStuct }} struct{}

// The terraform type name will be "{{ .TerraformTypeName }}"

{{ define "Attrs" }}
	// TfName        "{{.TfName}}"
	// Description   "{{.Description}}"
	// FrameworkType "{{.FrameworkType}}"
	// DataName      "{{.DataName}}"
	// DataType      "{{.DataType}}"
	{{ if .Attributes }}
	// Nested Attributes:
	{{- range $attribute := .Attributes }}{{ template "Attrs" $attribute }}{{- end}}
	{{ end }}
{{ end }}

// Attributes will be generated for this resource:
{{- range $attribute := .Attributes }}{{ template "Attrs" $attribute }}{{- end}}

// The factory function for this resource type will be "{{ .FactoryFunctionName }}"
`

func indent(spaces int, v string) string {
	pad := strings.Repeat("\t", spaces)
	return pad + strings.Replace(v, "\n", "\n"+pad, -1)
}

func (g *ResourceGenerator) Generate(destinationPkg, destinationSchema, destinationAccTest string) error {
	tmpl := template.Must(template.New("").Funcs(map[string]interface{}{
		"indent": indent,
	}).Parse(resourceSchemaTemplateBody))

	data := g.createTemplateData()
	var destCode string = destinationSchema + "resource_" + data.TerraformTypeName + ".go"
	f, err := os.Create(destCode)
	if err != nil {
		return fmt.Errorf("cannot save to destination \"%s\": %w", destCode, err)
	}
	defer f.Close()

	err = tmpl.Execute(f, data)

	return err
}

func (g *ResourceGenerator) createTemplateData() *TemplateResourceData {
	return &TemplateResourceData{
		PackageName:                  "provider",
		AcceptanceTestFunctionPrefix: "AccTest_",
		Attributes:                   g.templateAttributes(),
		TerraformTypeName:            g.tf.TfTypeNameSuffix,
		FactoryFunctionName:          fmt.Sprintf("%sType_%s", g.tf.TfType, g.tf.TfTypeNameSuffix),
		ConfigKey:                    g.spec.Name,
		ResourceTypeStuct:            fmt.Sprintf("Resource%sType", g.spec.Name),
		ResourceStruct:               fmt.Sprintf("Resource%s", g.spec.Name),
	}
}

func schemaToAttribute(nestingLevel int, name string, required bool, schema *openapi3.Schema) *TemplateResourceAttribute {
	templateAttribute := TemplateResourceAttribute{
		TfName:       naming.ToHCLName(name),
		Description:  "TODO",
		Required:     required,
		DataName:     naming.ToTitleName(name),
		DataType:     schema.Type,
		NestingLevel: nestingLevel,
	}

	// TODO: Does "additionalProperties" suggest a map?

	if schema.Type == "object" {
		nested := make([]*TemplateResourceAttribute, 0, len(schema.Properties))
		for propName, propRef := range schema.Properties {
			prop := propRef.Value
			// TODO: Required object attributes
			nested = append(nested, schemaToAttribute(nestingLevel+1, propName, false, prop))
		}
		templateAttribute.Attributes = nested
		templateAttribute.DataType = "ObjectType"
	} else if schema.Type == "array" {
		prop := schema.Items.Value
		if prop.Type != "object" {
			// This can be represented as a list
			templateAttribute.DataType = "ListType"
		} else {
			// TODO: ListNestedAttributes
			fmt.Printf("warning: ListNestedAttributes not yet supported for property %s\n", name)
		}
	} else {
		templateAttribute.DataType = toTerraformFrameworkType(toTerraformType(schema.Type))
	}

	return &templateAttribute
}

func (g *ResourceGenerator) templateAttributes() []*TemplateResourceAttribute {
	specAttributes := g.spec.CompositeAttributes(g.tf.MediaType)
	result := make([]*TemplateResourceAttribute, 0, len(specAttributes))

	for _, att := range specAttributes {
		result = append(result, schemaToAttribute(0, att.Name, att.ReadOnly, att.Schema))
	}

	return result
}

func NewResourceGenerator(rest *restutils.SpecResource, oapiSchema *openapi3.T, tf *config.TerraformResource) (*ResourceGenerator, error) {
	return &ResourceGenerator{
		rest,
		tf,
		oapiSchema,
	}, nil
}
