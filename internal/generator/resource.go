// work in progress & exploratory

package generator

import (
	"fmt"

	"github.com/brandonc/tfpgen/internal/config"
	"github.com/brandonc/tfpgen/pkg/naming"
	"github.com/brandonc/tfpgen/pkg/restutils"
	"github.com/getkin/kin-openapi/openapi3"
)

// ResourceGenerator is the type that generates code for each resource
type ResourceGenerator struct {
	Doc    *openapi3.T
	Config *config.Config

	currentResource  *restutils.RESTResource
	currentTerraform *config.TerraformResource
}

// TemplateResourceData describes a single resource to be templated
type TemplateResourceData struct {
	PackageName                  string
	AcceptanceTestFunctionPrefix string
	TerraformTypeName            string
	TerraformTypeNameTitle       string
	ConfigKey                    string
	ResourceStruct               string
	Description                  string
	Attributes                   []*TemplateResourceAttribute
}

var _ Generator = (*ResourceGenerator)(nil)

func (g *ResourceGenerator) Template() string {
	return `// Code generated by tfpgen; DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

type {{ .ResourceStruct }} struct{}

func New{{ .TerraformTypeName }}() resource.Resource {
	return &{{ .ResourceStruct }}{}
}

{{ define "DataStruct" }}struct {
	{{- range $attribute := .Attributes }}
		{{ if .IsComplex }}{{ .DataName }} {{ template "DataStruct" . }}{{ else }}
			{{ .DataName }} {{ .Schema.DataType }} ` + "`tfsdk:\"{{ .TfName }}\"`" + `
		{{ end }}
	{{- end}}
} ` + "`tfsdk:\"{{ .TfName }}\"`" + `{{ end }}

type {{ .ResourceStruct }}Data struct {
	{{- range $attribute := .Attributes }}
		{{ if .IsComplex }}{{ .DataName }} {{ template "DataStruct" . }}{{ else }}
			{{ .DataName }} {{ .Schema.DataType }} ` + "`tfsdk:\"{{ .TfName }}\"`" + `
		{{ end }}
	{{- end}}
}

func (r *{{ .ResourceStruct }}) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{ .TerraformTypeName }}"
}

{{ define "SimpleAttr" }}
	"{{.TfName}}": schema.{{.Schema.FrameworkSchemaAttributeType}}{
		MarkdownDescription: "{{ .Description }}",
		{{ if .Schema.ElementType }}ElementType: types.{{ .Schema.ElementType }},{{ end }}
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
	},{{ end }}
{{ define "ComplexListAttr" }}
	"{{.TfName}}": schema.ListNestedAttribute{
		MarkdownDescription: "{{ .Description }}",
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
		NestedObject:        schema.NestedAttributeObject{
			Attributes:        map[string]schema.Attribute{
				{{- range $attr := .Attributes }}{{ template "Attr" $attr }}{{- end}}
			},
		},
	},{{ end }}
{{ define "ComplexAttr" }}
	"{{.TfName}}": schema.SingleNestedAttribute{
		MarkdownDescription: "{{ .Description }}",
		Required:            {{ .Required }},
		Optional:            {{ .Optional }},
		Sensitive:           {{ .Sensitive }},
		Attributes:        map[string]schema.Attribute{
			{{- range $attr := .Attributes }}{{ template "Attr" $attr }}{{- end}}
		},
	},{{ end }}
{{ define "Attr" }}{{ if .IsComplex }}{{ if .IsList }}{{ template "ComplexListAttr" . }}{{ else }}{{ template "ComplexAttr" . }}{{ end }}{{ else }}{{ template "SimpleAttr" . }}{{ end }}{{ end }}
func (t *{{ .ResourceStruct }}) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "TODO",
		Attributes: map[string]schema.Attribute{
			{{- range $attribute := .Attributes }}{{ template "Attr" $attribute }}{{- end}}
		},
	}
}

func (r *{{ .ResourceStruct }}) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.Config.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.CreateExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to create example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "created a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.ReadExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to read example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "read a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.Plan.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.UpdateExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to update example, got error: %s", err))
	//     return
	// }

	diags = resp.State.Set(ctx, &data)
	resp.Diagnostics.Append(diags...)

	tflog.Info(ctx, "updated a {{ .ResourceStruct }} resource")
}

func (r *{{ .ResourceStruct }}) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data {{ .ResourceStruct }}Data

	diags := req.State.Get(ctx, &data)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	// If applicable, this is a great opportunity to initialize any necessary
	// provider client data and make a call using it.
	// example, err := d.provider.client.DeleteExample(...)
	// if err != nil {
	//     resp.Diagnostics.AddError("Client Error", fmt.Sprintf("Unable to delete example, got error: %s", err))
	//     return
	// }

	resp.State.RemoveResource(ctx)

	tflog.Info(ctx, "deleted a {{ .ResourceStruct }} resource")
}
`
}

func (g *ResourceGenerator) PackageName() string {
	return g.Config.Provider.PackageName
}

func (g *ResourceGenerator) Generate(destinationPath string) error {
	bindings, err := g.Config.AsBindings()
	if err != nil {
		// Provided error message is adequate
		return err
	}

	probe := restutils.NewProbe(g.Doc)
	resources, err := probe.BindResources(bindings)

	if err != nil {
		// Provided error message is adequate
		return err
	}

	for key := range g.Config.Output {
		resource, ok := resources[key]
		if !ok {
			return fmt.Errorf("could not find configured entity key \"%s\" in %s", key, g.Config.Filename)
		}

		if resource.IsCRUD() {
			g.currentResource = resource
			g.currentTerraform = g.Config.Output[key]

			err = execute(g, fmt.Sprintf("%s/resource_%s.go", destinationPath, g.currentTerraform.TfTypeNameSuffix))
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (g *ResourceGenerator) CreateTemplateData() interface{} {
	return &TemplateResourceData{
		PackageName:                  "provider",
		AcceptanceTestFunctionPrefix: "AccTest_",
		Attributes:                   templateAttributes(g.currentResource, g.currentTerraform),
		TerraformTypeName:            g.currentTerraform.TfTypeNameSuffix,
		TerraformTypeNameTitle:       naming.ToTitleName(g.currentTerraform.TfTypeNameSuffix),
		ConfigKey:                    g.currentResource.Name,
		ResourceStruct:               fmt.Sprintf("Resource%s", g.currentResource.Name),
	}
}

func NewResourceGenerator(doc *openapi3.T, config *config.Config) *ResourceGenerator {
	return &ResourceGenerator{
		Doc:    doc,
		Config: config,
	}
}
